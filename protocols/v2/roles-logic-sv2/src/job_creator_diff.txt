diff --git a/protocols/v2/roles-logic-sv2/src/job_creator.rs b/protocols/v2/roles-logic-sv2/src/job_creator.rs
index 67cfe9ad..68b93ee7 100644
--- a/protocols/v2/roles-logic-sv2/src/job_creator.rs
+++ b/protocols/v2/roles-logic-sv2/src/job_creator.rs
@@ -6,7 +6,16 @@ use mining_sv2::NewExtendedMiningJob;
 use nohash_hasher::BuildNoHashHasher;
 use std::{collections::HashMap, convert::TryInto};
 use template_distribution_sv2::{NewTemplate, SetNewPrevHash};
-use tracing::debug;
+use tracing::{debug, info, error};
+use secp256k1::{Secp256k1, SecretKey, PublicKey, Message};
+use secp256k1::ecdsa::{RecoverableSignature};
+use base64;
+use openssl::symm::{Cipher, Crypter, Mode};
+use openssl::pkcs5::pbkdf2_hmac;
+use openssl::hash::MessageDigest;
+use sha2::{Sha256, Digest};
+use hex;
+use base58::FromBase58;
 
 use stratum_common::{
     bitcoin,
@@ -71,6 +80,10 @@ impl JobsCreators {
         version_rolling_allowed: bool,
         mut pool_coinbase_outputs: Vec<TxOut>,
         pool_signature: String,
+        tbc_encrypted_kyc_privkey: String,
+        decryption_password: String,
+        tbc_miner_kyc_sig: String,
+        charge_addr: String,
     ) -> Result<NewExtendedMiningJob<'static>, Error> {
         let server_tx_outputs = template.coinbase_tx_outputs.to_vec();
         let mut outputs = tx_outputs_to_costum_scripts(&server_tx_outputs);
@@ -88,6 +101,10 @@ impl JobsCreators {
             template,
             &mut pool_coinbase_outputs,
             pool_signature,
+            tbc_encrypted_kyc_privkey,
+            decryption_password,
+            tbc_miner_kyc_sig,
+            charge_addr,
             next_job_id,
             version_rolling_allowed,
             self.extranonce_len,
@@ -138,6 +155,10 @@ impl JobsCreators {
 pub fn extended_job_from_custom_job(
     referenced_job: &mining_sv2::SetCustomMiningJob,
     pool_signature: String,
+    tbc_encrypted_kyc_privkey: String,
+    decryption_password: String,
+    tbc_miner_kyc_sig: String,
+    charge_addr: String,
     extranonce_len: u8,
 ) -> Result<NewExtendedMiningJob<'static>, Error> {
     let mut outputs =
@@ -159,6 +180,10 @@ pub fn extended_job_from_custom_job(
         &mut template,
         &mut outputs,
         pool_signature,
+        tbc_encrypted_kyc_privkey,
+        decryption_password,
+        tbc_miner_kyc_sig,
+        charge_addr,
         0,
         true,
         extranonce_len,
@@ -178,11 +203,15 @@ fn new_extended_job(
     new_template: &mut NewTemplate,
     coinbase_outputs: &mut [TxOut],
     pool_signature: String,
+    tbc_encrypted_kyc_privkey: String,
+    decryption_password: String,
+    tbc_miner_kyc_sig: String,
+    charge_addr: String,
     job_id: u32,
     version_rolling_allowed: bool,
     extranonce_len: u8,
 ) -> Result<NewExtendedMiningJob<'static>, Error> {
-    coinbase_outputs[0].value = match new_template.coinbase_tx_value_remaining.checked_mul(1) {
+    let value_remaining = match new_template.coinbase_tx_value_remaining.checked_mul(1) {
         //check that value_remaining is updated by TP
         Some(result) => result,
         None => return Err(Error::ValueRemainingNotUpdated),
@@ -192,15 +221,91 @@ fn new_extended_job(
         .try_into()
         .map_err(|_| Error::TxVersionTooBig)?;
 
+    let not_segwit = get_bip_seg_wit_flag(new_template);
     let bip34_bytes = get_bip_34_bytes(new_template, tx_version)?;
-    let script_prefix_len = bip34_bytes.len() + pool_signature.as_bytes().len();
+    let height_data = get_block_height_data(&bip34_bytes);
+
+    let message_vec: Vec<u8>  = height_data.to_vec().into_iter().rev().collect();
+    let message: [u8; 3] = message_vec.try_into().expect("Expected a Vec of length 3");
+    let double_sha256 = double_sha256(&message);
+
+    // 准备数据
+    let encrypted_data = base64::decode(tbc_encrypted_kyc_privkey)
+        .map_err(|_| Error::KYCBusiness)?;
+
+    // 解密私钥
+    let private_key = decrypt_private_key(&encrypted_data, &decryption_password)?;
+
+    // 生成公钥
+    let secp = Secp256k1::new();
+    let public_key = create_and_serialize_pubkey(&secp, &private_key)
+        .map_err(|_| Error::KYCBusiness)?;
+    let public_key_serialized = public_key.serialize();
+    
+    // 生成sigB
+    let signature_der = sign_message_with_private_key(&double_sha256, &private_key)
+        .map_err(|e| {
+            error!("todo debug : {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 读取抽成比例
+    let fee_percentage_result = get_fee_percentage(&tbc_miner_kyc_sig);
+    let fee_percentage = match fee_percentage_result {
+        Ok(percentage) => percentage,
+        Err(e) => {
+            eprintln!("Error getting fee percentage: {:?}", e);
+            return Err(e);
+        }
+    };
+
+    // 组装 KYC output script
+    let mut vec_tbc_charge_output = Vec::<u8>::new();
+
+    let mut addr_script = Vec::new();
+    let _add_script_size = address_to_script(&mut addr_script, &charge_addr);
+    
+    vec_tbc_charge_output.extend(addr_script);
+
+    let encrypted_data = hex::decode(tbc_miner_kyc_sig)
+        .map_err(|_| Error::KYCBusiness)?;
+    let script_to_tal_len: u8 = 1 + public_key_serialized.to_vec().len() as u8 + 1 + encrypted_data.to_vec().len() as u8;
+
+    vec_tbc_charge_output.push(0x6a);                                   // OP_RETURN
+    vec_tbc_charge_output.push(0x4c);
+    vec_tbc_charge_output.push(script_to_tal_len);
+    vec_tbc_charge_output.push(0x01);                                   // KYC flag
+    vec_tbc_charge_output.extend_from_slice(&public_key_serialized);
+    vec_tbc_charge_output.extend(encrypted_data);
+
+    // 数据处理
+    let script_prefix_len = bip34_bytes.len() + signature_der.to_vec().len();
+    
+    let charge_txout = TxOut {
+        value: (value_remaining * u64::from(fee_percentage)) / 100,
+        script_pubkey: vec_tbc_charge_output.into(),
+    };
+
+    coinbase_outputs[0].value = value_remaining - charge_txout.value;
+
+    // Convert charge_txout to a Vec
+    let mut coinbase_outputs_vec = Vec::new();
+    coinbase_outputs_vec.push(charge_txout);
+
+    // Append the existing coinbase_outputs
+    coinbase_outputs_vec.extend_from_slice(&coinbase_outputs);
+
+    // Update coinbase_outputs as a mutable slice
+    let coinbase_outputs: &mut [TxOut] = coinbase_outputs_vec.as_mut_slice();
 
     let coinbase = coinbase(
         bip34_bytes,
+        not_segwit,
         tx_version,
         new_template.coinbase_tx_locktime,
         new_template.coinbase_tx_input_sequence,
         coinbase_outputs,
+        hex::encode(&signature_der),
         pool_signature,
         extranonce_len,
     );
@@ -223,8 +328,8 @@ fn new_extended_job(
         version: new_template.version,
         version_rolling_allowed,
         merkle_path: new_template.merkle_path.clone().into_static(),
-        coinbase_tx_prefix: coinbase_tx_prefix(&coinbase, script_prefix_len)?,
-        coinbase_tx_suffix: coinbase_tx_suffix(&coinbase, extranonce_len, script_prefix_len)?,
+        coinbase_tx_prefix: coinbase_tx_prefix(&coinbase, not_segwit, script_prefix_len)?,
+        coinbase_tx_suffix: coinbase_tx_suffix(&coinbase, not_segwit, extranonce_len, script_prefix_len)?,
     };
 
     debug!(
@@ -238,19 +343,21 @@ fn new_extended_job(
 /// so the extranonce search space can be introduced
 fn coinbase_tx_prefix(
     coinbase: &Transaction,
+    not_segwit: bool,
     script_prefix_len: usize,
 ) -> Result<B064K<'static>, Error> {
     let encoded = coinbase.serialize();
     // If script_prefix_len is not 0 we are not in a test environment and the coinbase will have the 0
     // witness
-    let segwit_bytes = match script_prefix_len {
-        0 => 0,
-        _ => 2,
+    let segwit_bytes = if not_segwit {
+        0
+    } else {
+        2
     };
     let index = 4    // tx version
         + segwit_bytes
         + 1  // number of inputs TODO can be also 3
-        + 32 // prev OutPoint
+        + 32 // prev txid
         + 4  // index
         + 1  // bytes in script TODO can be also 3
         + script_prefix_len; // bip34_bytes
@@ -262,15 +369,17 @@ fn coinbase_tx_prefix(
 /// so the extranonce search space can be introduced
 fn coinbase_tx_suffix(
     coinbase: &Transaction,
+    not_segwit: bool,
     extranonce_len: u8,
     script_prefix_len: usize,
 ) -> Result<B064K<'static>, Error> {
     let encoded = coinbase.serialize();
     // If script_prefix_len is not 0 we are not in a test enviornment and the coinbase have the 0
     // witness
-    let segwit_bytes = match script_prefix_len {
-        0 => 0,
-        _ => 2,
+    let segwit_bytes = if not_segwit {
+        0
+    } else {
+        2
     };
     let r = encoded[4    // tx version
         + segwit_bytes
@@ -319,23 +428,372 @@ fn get_bip_34_bytes(new_template: &NewTemplate, tx_version: i32) -> Result<Vec<u
     }
 }
 
+fn get_block_height_data(bip34_bytes: &[u8]) -> &[u8] {
+    // 获取第一个字节，表示后续高度字节的长度
+    let len = bip34_bytes[0] as usize;
+
+    // 确保不会越界访问
+    if bip34_bytes.len() < len + 1 {
+        panic!("bip34_bytes length is less than expected height length.");
+    }
+    
+    let height_bytes = &bip34_bytes[1..len+1];
+    height_bytes
+}
+
+fn double_sha256(data: &[u8]) -> Vec<u8> {
+    let mut hasher = Sha256::new();
+    hasher.update(data);
+    let result = hasher.finalize_reset();
+
+    hasher.update(&result);
+    hasher.finalize().to_vec()
+}
+
+fn get_bip_seg_wit_flag(new_template: &NewTemplate) -> bool {
+    new_template.coinbase_tx_locktime == 0
+}
+
+fn decrypt_private_key(encrypted_data: &[u8], password: &str) -> Result<Vec<u8>, Error> {
+    let salt = &encrypted_data[0..16];
+    let iv = &encrypted_data[16..32];
+    let ciphertext = &encrypted_data[32..];
+
+    // 使用PBKDF2生成密钥
+    let mut key = vec![0u8; 32];
+    pbkdf2_hmac(password.as_bytes(), salt, 1000000, MessageDigest::sha256(), &mut key)
+        .map_err(|e| {
+            error!("Error creating key with PBKDF2: {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 解密初始化
+    let cipher = Cipher::aes_256_cfb128();
+    let mut crypter = Crypter::new(cipher, Mode::Decrypt, &key, Some(iv))
+        .map_err(|e| {
+            error!("Error initializing crypter with AES-256-CFB128: {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 解密更新
+    let mut decrypted_key = vec![0; ciphertext.len() + cipher.block_size()];
+    let mut count = crypter.update(ciphertext, &mut decrypted_key)
+        .map_err(|e| {
+            error!("Error updating crypter with ciphertext: {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 解密完成
+    count += crypter.finalize(&mut decrypted_key[count..])
+        .map_err(|e| {
+            error!("Error finalizing decryption process: {:?}", e);
+            Error::KYCBusiness
+        })?;
+    decrypted_key.truncate(count);
+
+    Ok(decrypted_key)
+}
+
+fn create_and_serialize_pubkey(ctx: &Secp256k1<secp256k1::All>, private_key: &[u8]) -> Result<PublicKey, String> {
+    let secret_key = SecretKey::from_slice(private_key).map_err(|_| "Error decoding private key".to_string())?;
+    let public_key = PublicKey::from_secret_key(ctx, &secret_key);
+
+    Ok(public_key)
+}
+
+fn sign_message_with_private_key(double_sha256: &[u8], private_key: &[u8]) -> Result<Vec<u8>, Error> {
+    // 创建Secp256k1上下文
+    let secp = Secp256k1::new();
+
+    // 将私钥字节数组转换为SecretKey
+    let private_key = SecretKey::from_slice(private_key)
+        .map_err(|e| {
+            error!("todo debug : {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 将哈希结果转换为Message
+    let message = Message::from_slice(double_sha256)
+        .map_err(|e| {
+            error!("todo debug: {:?}", e);
+            Error::KYCBusiness
+        })?;
+
+    // 创建可恢复的签名
+    let sig: RecoverableSignature = secp.sign_ecdsa_recoverable(&message, &private_key);
+
+    // 将可恢复的签名转换为标准签名
+    let standard_sig = sig.to_standard();
+
+    // 将标准签名序列化为DER格式
+    let serialized_sig = standard_sig.serialize_der().as_ref().to_vec();
+
+    Ok(serialized_sig)
+}
+
+fn get_fee_percentage(hex_string: &str) -> Result<u8, Error> {
+    // 解码十六进制字符串
+    let encrypted_data = hex::decode(hex_string)
+        .map_err(|_| Error::KYCBusiness)?;
+    
+    // 获取最后一个字节
+    let last_byte = encrypted_data.last()
+        .ok_or_else(|| {
+            error!("Failed to get the last byte: encrypted_data is empty.");
+            Error::KYCBusiness
+        })?;
+    
+    Ok(*last_byte)
+}
+
+
+const BECH32_CHARSET_REV: [i8; 128] = [
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, 15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25,  9,  8,
+    23, -1, 18, 22, 31, 27, 19, -1,  1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
+    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,  1,  0,  3, 16, 11, 28, 12, 14,
+     6,  4,  2, -1, -1, -1, -1, -1
+];
+
+fn b58dec(addr: &str) -> Option<[u8; 25]> {
+    match addr.from_base58() {
+        Ok(decoded) if decoded.len() == 25 => {
+            let mut addrbin = [0u8; 25];
+            addrbin.copy_from_slice(&decoded);
+            Some(addrbin)
+        }
+        _ => None,
+    }
+}
+
+fn b58check(addrbin: &[u8]) -> i32 {
+    if addrbin.len() != 25 {
+        return -1;
+    }
+
+    let checksum_index = addrbin.len() - 4;
+    let payload = &addrbin[..checksum_index];
+    let checksum = &addrbin[checksum_index..];
+
+    let hash = Sha256::digest(&Sha256::digest(payload));
+    if &hash[0..4] != checksum {
+        return -1;
+    }
+
+    let zeros = addrbin.iter().take_while(|&&b| b == 0).count();
+    if addrbin[zeros] == 0 {
+        return -3;
+    }
+
+    addrbin[0] as i32
+}
+
+fn convert_bits(out: &mut Vec<u8>, outbits: usize, input: &[u8], inbits: usize, pad: bool) -> bool {
+    let mut val = 0;
+    let mut bits = 0;
+    let maxv = (1 << outbits) - 1;
+
+    for &byte in input {
+        val = (val << inbits) | (byte as usize);
+        bits += inbits;
+
+        while bits >= outbits {
+            bits -= outbits;
+            out.push(((val >> bits) & maxv) as u8);
+        }
+    }
+
+    if pad {
+        if bits > 0 {
+            out.push(((val << (outbits - bits)) & maxv) as u8);
+        }
+    } else if (val << (outbits - bits)) & maxv != 0 || bits >= inbits {
+        return false;
+    }
+
+    true
+}
+
+fn bech32_polymod_step(pre: u32) -> u32 {
+    let b = pre >> 25;
+    ((pre & 0x1ffffff) << 5)
+        ^ (if (b & 1) != 0 { 0x3b6a57b2 } else { 0 })
+        ^ (if (b & 2) != 0 { 0x26508e6d } else { 0 })
+        ^ (if (b & 4) != 0 { 0x1ea119fa } else { 0 })
+        ^ (if (b & 8) != 0 { 0x3d4233dd } else { 0 })
+        ^ (if (b & 16) != 0 { 0x2a1462b3 } else { 0 })
+}
+
+fn bech32_decode(hrp: &mut String, data: &mut Vec<u8>, input: &str) -> bool {
+    let mut chk = 1u32;
+    let mut have_lower = false;
+    let mut have_upper = false;
+
+    if input.len() < 8 || input.len() > 90 {
+        return false;
+    }
+
+    let mut data_part_len = 0;
+    for (i, c) in input.chars().rev().enumerate() {
+        if c == '1' {
+            data_part_len = i;
+            break;
+        }
+    }
+    let hrp_len = input.len() - (1 + data_part_len);
+
+    if 1 + data_part_len >= input.len() || data_part_len < 6 {
+        return false;
+    }
+
+    for c in input.chars().take(hrp_len) {
+        if c.is_ascii_lowercase() {
+            have_lower = true;
+        } else if c.is_ascii_uppercase() {
+            have_upper = true;
+        }
+        if let Some(ch) = c.to_ascii_lowercase().to_digit(36) {
+            chk = bech32_polymod_step(chk) ^ (ch >> 5);
+            hrp.push(c);
+        } else {
+            return false;
+        }
+    }
+
+    chk = bech32_polymod_step(chk);
+
+    for c in input.chars().take(hrp_len) {
+        chk = bech32_polymod_step(chk) ^ ((c as u32) & 0x1f);
+    }
+
+    for (i, c) in input.chars().skip(hrp_len + 1).enumerate() {
+        if c.is_ascii_lowercase() {
+            have_lower = true;
+        } else if c.is_ascii_uppercase() {
+            have_upper = true;
+        }
+        if let Some(&v) = BECH32_CHARSET_REV.get(c as usize) {
+            if v == -1 {
+                return false;
+            }
+            chk = bech32_polymod_step(chk) ^ (v as u32);
+            if i + 6 < input.len() - hrp_len - 1 {
+                data.push(v as u8);
+            }
+        } else {
+            return false;
+        }
+    }
+
+    if have_lower && have_upper {
+        return false;
+    }
+
+    chk == 1
+}
+
+fn segwit_addr_decode(addr: &str) -> Option<(u8, Vec<u8>)> {
+    let mut hrp = String::new();
+    let mut data = Vec::new();
+    if !bech32_decode(&mut hrp, &mut data, addr) {
+        return None;
+    }
+
+    if data.len() == 0 || data.len() > 65 || data[0] > 16 {
+        return None;
+    }
+
+    let mut witdata = Vec::new();
+    if !convert_bits(&mut witdata, 8, &data[1..], 5, false) {
+        return None;
+    }
+
+    if witdata.len() < 2 || witdata.len() > 40 || (data[0] == 0 && witdata.len() != 20 && witdata.len() != 32) {
+        return None;
+    }
+
+    Some((data[0], witdata))
+}
+
+fn bech32_to_script(out: &mut Vec<u8>, addr: &str) -> usize {
+    if let Some((witver, witprog)) = segwit_addr_decode(addr) {
+        let witprog_len = witprog.len();
+        if out.len() < witprog_len + 2 {
+            return 0;
+        }
+        out.push(if witver > 0 { 0x50 + witver } else { 0 });
+        out.push(witprog_len as u8);
+        out.extend_from_slice(&witprog);
+        witprog_len + 2
+    } else {
+        0
+    }
+}
+
+fn address_to_script(out: &mut Vec<u8>, addr: &str) -> usize {
+    let addrbin;
+    let addrver;
+
+    if let Some(decoded) = b58dec(addr) {
+        addrbin = decoded;
+    } else {
+        return bech32_to_script(out, addr);
+    }
+
+    addrver = b58check(&addrbin);
+    if addrver < 0 {
+        return 0;
+    }
+
+    match addrver {
+        5 | 196 => {
+            out.push(0xa9);
+            out.push(0x14);
+            out.extend_from_slice(&addrbin[1..21]);
+            out.push(0x87);
+            23
+        }
+        _ => {
+            out.push(0x76);
+            out.push(0xa9);
+            out.push(0x14);
+            out.extend_from_slice(&addrbin[1..21]);
+            out.push(0x88);
+            out.push(0xac);
+            25
+        }
+    }
+}
+
 /// coinbase_tx_input_script_prefix: extranonce prefix (script lenght + bip34 block height) provided by the node
 /// It assume that NewTemplate.coinbase_tx_outputs == 0
 fn coinbase(
     mut bip34_bytes: Vec<u8>,
+    not_segwit: bool,
     version: i32,
     lock_time: u32,
     sequence: u32,
     coinbase_outputs: &[TxOut],
+    privkey_sig: String,
     pool_signature: String,
     extranonce_len: u8,
 ) -> Transaction {
-    // If script_prefix_len is not 0 we are not in a test enviornment and the coinbase have the 0
-    // witness
-    let witness = match bip34_bytes.len() {
-        0 => Witness::from_vec(vec![]),
-        _ => Witness::from_vec(vec![vec![0; 32]]),
+    // If bit_segwit is true, we are not in a SegWit environment and the coinbase does not have the witness field
+    // If bit_segwit is false, we are in a SegWit environment and the coinbase has a 0 witness
+    let witness = if not_segwit {
+        Witness::from_vec(vec![])
+    } else {
+        Witness::from_vec(vec![vec![0; 32]])
     };
+
+    //TODO FSJ 此处pubkeyB放错位置，应该放在outputScript
+    // let pool_signature_bytes = base64::decode(&pool_signature).expect("Invalid base64 in pool_signature");
+    // info!("pool_signature_bytes:{:?}", pool_signature_bytes);
+
+    let decoded_vec = hex::decode(&privkey_sig).expect("Decoding failed");
+
+    bip34_bytes.extend_from_slice(&decoded_vec);
     bip34_bytes.extend_from_slice(pool_signature.as_bytes());
     bip34_bytes.extend_from_slice(&vec![0; extranonce_len as usize]);
     let tx_in = TxIn {
@@ -344,6 +802,7 @@ fn coinbase(
         sequence: bitcoin::Sequence(sequence),
         witness,
     };
+    info!("tx_in:{:?}",tx_in);
     Transaction {
         version,
         lock_time: bitcoin::PackedLockTime(lock_time),
